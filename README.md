# Corlib
# 项目背景
本项目是在完成webserver之后的进阶项目，支持异步、参考了开源项目sylar，用于巩固基础知识，锻炼实操能力。

# 项目描述
本项目是Linux环境下使用C++开发的部分服务器框架，主要实现了协程库的编写，基于ucontext_t实现了协程类。基于epoll和定时器实现了N-M协程调度模型，支持IO事件，定时器事件的回调。基于协程调度，对常见系统API进行hook封装实现异步，对锁进行了封装以实现同步。同时还支持多线程和高效的数据处理。

- **线程封装**：封装了pthread，互斥量，信号量，读写锁，自旋锁，实现范围局部锁。
- **协程实现**：基于ucontext_t实现了非对称协程，设计了三种协程状态，使子协程可以和线程主协程、调度协程相互切换。
- **异步支持**：基于时间堆实现了定时器功能，支持定时事件任务的添加、删除、更新。
- **框架调试**：实现了N-M协程调度器，支持主线程参与任务调度，在基本的协程调度器基础上结合epoll和定时器实现了I/O协程调度，支持I/O事件和定时器事件的注册和响应。
- **Hook**：基于IO协程调度器堆sleep系列、SocketIO系列、fd操作系列系统调用进行hook封装以实现阻塞调用的异步处理，实现对CPU的高效利用。
- **测试**：为进行测试，使用原生epoll，libevent，libco库和本项目分别编写单线程服务器，分别进行ApacheBench和自写客户端进行压力测试，数据响应1000000条，并发连接数为1000，RPS分别是26339.64和21369、27616.68和22000.4、25744.8和20748.9、26676.04和21613，性能并无太多差异。说明单线程下本项目几乎没有性能损失。又在多线程下进行多次测试，本项目能相比于其他提升25%左右的性能，证明了本项目在大流量、多线程、IO密集条件下工作具有一定的优势。
- **项目难点**：基于epoll和定时器实现多线程IO协程调度器，支持对定时任务协程和IO任务协程的调度，且支持主线程（创建调度器的线程）参与调度。对sleep、IO等阻塞系统调用进行hook封装，在函数内部进行协程切换，将阻塞系统调用改造为非阻塞。
- **个人收获**：深入了解了协程技术，熟悉了共享栈、对称/非对称协程等概念；了解了主要协程库的优缺点以及适用场景，对进程、线程、协程的区别有了更深入的了解；熟练掌握了Linux网络编程、系统编程接口，对IO多路复用、事件驱动模型有了一定的了解。

# 性能比较

## 客户端模式（1000进程，60秒）

| 库名称    | 请求总数 | 每秒请求数 (RPS) |
|-----------|----------|------------------|
| corlib    | 1,296,780| 21,613           |
| libco     | 1,244,936| 20,748.9         |
| libevent  | 1,320,024| 22,000.4         |
| epoll     | 1,282,137| 21,369           |

## Apache 性能测试（1000000条数据，1000并发量）

| 库名称    | 单线程每秒请求数 (RPS) |
|-----------|------------------------|
| corlib    | 26,676.04              |
| libco     | 25,744.8               |
| libevent  | 27,616.68              |
| epoll     | 26,339.64              |

## 分析
1. **请求总数**：libevent 在单线程和多进程模式下表现出最高的请求处理能力，处理的总请求数最多。
2. **每秒请求数**：在多进程测试中，所有库的每秒请求数 (RPS) 都表现相近，但 libevent 略微领先。
3. **单线程性能**：单线程模式下，libevent 同样显示了较高的性能，其次是 corlib，然后是 epoll，libco 的性能略低。

## 结论
- **libevent** 在这项测试中表现最佳，无论是在处理高并发还是单线程情况下，都能处理更多的请求。
- **corlib** 和 **epoll** 在单线程模式下的表现相似，但 corlib 的多进程处理能力略胜一筹。
- **libco** 在这四种测试库中表现稍微逊色，但仍然保持了较高的性能水平。

这些数据可以帮助在开发和优化高性能服务器应用程序时，根据特定需求选择合适的库。
